一、jsx语法
    1、在react当中,可以将xml元素当成js的变量处理。可以将html标签赋值给js变量,可以当做参数传递
    2、jsx在解析是,遇到尖括号开头的就用html规则解析,否则就用js规则解析
    3、模板语法:使用单花括号表示。可以js变量,数学运算,三目运算,循环等

二、组件(component)
    1、是一段html,css,js的一段聚合体
    2、react中组件分类组件和函数式组件
    3、创建组件:
        1)、创建类组件要继承Component或PureComponent,实现render方法,返回jsx元素
        2)、函数式组件直接返回jsx元素
        3)、组件名称首字母要大写,建议大驼峰写法,标签属性用小驼峰写法
        4)、创建之后直接在父组件引入就可以使用了
    4、类组件创建状态数据
        1)、给state赋值对象,对象中声明状态数据
        2)、在页面上取状态数据显示时,直接单花括号取this.state中的属性即可
        3)、修改state数据时,调用this.setState触发state数据修改,并更新页面
    5、添加事件
        1)、react中事件只支持DOM 0级的事件添加方式,即在标签内写事件名称并赋值函数
        2)、事件名称都是小驼峰名称,不是原生的dom事件名称,赋值的函数有默认形参,是事件对象
        3)、注意事件函数内的this指向
        4)、当需要对事件函数传参,并获取事件对象,且this指向不需要手动修改时,一般是给事件绑定箭头函数,箭头函数内再执行外部函数
        5)、合成事件:react利用事件冒泡机制将所有标签的事件名称和事件函数全部加到document上进行统一管理,优化首次渲染的性能
    6、组件传值
        1)、父传子:父传子通过自定义属性传一个数据,子组件通过props接收
        2)、子传父:通过父组件传一个函数,在子组件中通过props拿到该函数并执行,执行时传的参数即可在父组件获取到
        3)、嵌套组件传值:通过createContext创建上下文对象,在祖先组件中通过context中Provider组件的value属性暴露数据
        4)、在类组件中通过设置类组件contextType静态属性为上下文对象后,在this.context中可获取数据
        5)、在函数式组件中通过执行useContext这个hook函数获取数据
        6)、非嵌套组件传值通过第三部的events包实现,创建EventEmitter实例,通过实例的on方法声明全局事件,通过emit触发全局事件
    7、生命周期
        1)、创建期(挂载期):constructor、UNSAFE_componentWillMount,render,componentDidMount
        2)、更新期:shouldComponentUpdate、UNSAFE_componentWillUpdate,render,componentDidUpdate
        3)、销毁期(卸载期):componentWillUnmount
    8、Refs和DOM
        1)、findDOMNode:接收一个组件实例,可以获取该组件的DOM元素
        2)、root.unmount:卸载实例
        3)、ref:在类组件中获取标签的DOM对象或子组件的实例,在函数式组件中获取DOM对象或子组件(forwardRef处理)的DOM结构
                老用法就直接赋值字符串,新用法用createRef创建引用实例,再赋值给标签内的ref属性
                标签内的ref属性可以接收字符串,createRef实例,和函数(函数的形参就是引用)。
    9、受控组件
        1)、react中没有双向绑定,对表单元素的控制需要开发者自己实现
        2)、受控组件的定义是表单元素的值受到state状态数据的控制、必须实现onChange事件修改state数据
        3)、多表单元素受控时,给元素加上name属性,name属性取值时与state中属性名称保持一致,通过封装统一的onChange事件函数对所有表单元素赋值
    10、props进阶
        1)、props中有个隐藏的属性为children,当在组件双标签中写内容时,在子组件中通过该属性可以获取标签中的内容
        2)、react提供了React.Children.map,React.Children.forEach,React.Children.count等方法处理children
        3)、通过children也可以实现父子组件传值,可以模拟插槽功能,模拟具名插槽时需要借助自定义属性
    11、网络请求
        1)、通过在src下创建setupProxy.js文件,设置服务器反向代理,解决跨域问题
        2)、通过判断运行环境(process.env.NODE_ENV)动态修改baseURL
    12、高阶组件
        1)、高阶函数本身是一个函数,接收一个函数作为参数,返回一个新的函数,新函数在原有的参数函数基础上做了增强
        2)、高阶组件本身也是一个函数,接收一个组件作为参数,返回一个新的组件,新组建在原有的参数组件上做了增强
        3)、高阶组件不是react中个的知识点,是利用设计模式中的装饰器模式改造组件结构
        4)、装饰器语法
    13、hook函数
        1)、对于函数式组件没有实例的情况,react提供了一系列hooks来弥补,hook函数只能用于函数式组件
        2)、useState声明状态数据
        3)、useEffect模拟生命周期(componentDidMount,componentDidUpdate,componentWillUnmount)
        4)、useRef在函数式组件中或去标签的dom对象或子组件dom结构
        5)、useReducer管理复杂的状态数据
        6)、useMemo缓存一个数据,当数据计算的依赖项不发生值改变时,不会重新计算(类似于vue中的计算属性)
        7)、useCallBack缓存一个函数,当函数中个的数据项不发生值改变时,不会重复创建函数
        8)、自定义hook函数,hook本质是个函数,在封装的函数中亦可使用其他hook函数

三、路由(react-router-dom)
    1、路由是url与资源的一组对应关系
    2、react的路由分5版本和6版本,主要用5版本
    3、BrowserRouter创建路由对象,Switch设置路由显示出口,Route声明路由关系(处理404问题),Redirect声明重定向
    4、路由中组件渲染方式有component(有路由对象),render(无路由对象),Router标签内(无路由对象)写法
    5、声明式导航(Link和NavLink),一般使用NavLink,其渲染时有active的样式供我们使用
    6、编程式导航通过路由对象中的history实现(push,replace,go,goFoward,goBack)
    7、在没有路由对象的页面或组件中使用withRouter高阶组件进行处理
    8、路由传参:在声明式导航或编程式导航中,都可以使用动态url传参(match.params),query传参(location.query),state传参(location.state)
    9、嵌套路由
        1)、父路由不能使用精确匹配(exact)
        2)、子路由在二级页面中声明
        3)、子路由的path要写绝对路径
    10、路由中的hook函数
        1)、useHistory获取history对象
        2)、useLocation获取location
        3)、useParams获取动态url的传参
        4)、useRouteMatch获取当前页面的路由地址
    11、路由懒加载
        1)、将组件通过react中的lazy方法实现懒加载
        2)、在懒加载的过渡期使用Suspense组件处理,可以通过fallback属性实现页面临时过渡效果
    12、路由V6版本的使用方法

四、状态管理(redux)
    1、redux是一个纯js的框架,用于实现状态数据的集中式管理
    2、通过redux中的createStore方法创建实例
    3、创建实例时需要传入一个reducer函数,该函数用于实现状态数据的处理逻辑,接收两个形参(state和action)
    4、state是状态数据树(做一次深拷贝),action是操作数据
    5、通过实例的getState方法获取数据,通过dispatch方法触发reducer函数执行,从而修改数据。修改数据会触发subscribe监听函数执行
    6、代码模块化:封装actionTypes,actions,reducers(使用combineReducer合并)
    7、react-redux插件
        1)、从插件中解构出Provider组件,将store实例传入组件,Provider组件要作为顶级组件包裹App组件
        2)、在需要使用的页面上通过解构出来的connect方法映射state和dispatch
        3)、映射的数据和方法会被添加到props中
    8、中间件
        1)、中间件就是在既有的流程基础上增加额外的流程,完善整个应用
        2)、redux-logger,redux-thunk(redux-saga)
        3)、自定义中间件