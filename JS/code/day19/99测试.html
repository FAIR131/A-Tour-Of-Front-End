<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      //1.数组当中包含相同的元素，要求去除数组相同的元素
      // var arr = [3,2,1,2,3,2,1,4_express脚手架,1,7];
      // let s =new Set(arr);
      // console.log([...s]);

      //   var arr = [3,2,1,2,3,2,1,4_express脚手架,1,7];var arr = [3,2,1,2,3,2,1,4_express脚手架,1,7]; //结果为[3,2,1,4_express脚手架,7]
      //   (function(){
      //         for(var i=0;i<arr.length-1;i++){
      //             for(var j = i+1;j<arr.length;j++){
      //                 if(arr[j]===arr[i]){
      //                     arr.splice(j,1);
      //                     j--;
      //                 }
      //             }
      //         }
      //         console.log(arr);
      //     })()
    </script>
    <script>
      //2.给Object类型设置一个forEach属性,可以对对象循环
      Object.prototype.xunhuan = function () {
        for (let k in obj) {
          console.log(k, obj[k]);
        }
      };

      let obj = {
        name: "zs",
        age: 18,
        sex: "男",
      };

      obj.xunhuan();
    </script>
    <script>
      //3.面向对象的三大特征是什么？你是如何理解的?
      /*        面向对象的三大特性

​			           \- 1.封装 : 打包代码

​                \- 2.继承 : 减少相似功能的代码书写

​                \- 3.多态 : 自然形成
                        多态的具体表现为方法重载和方法重写：
                      对象继承的时候,属性或方法的名称相同,后者覆盖前者,过程叫做重写
                     子类继承了父类的同名方法,但是参数不一致,则允许两种方法同时存在,根据参数的数量来区别不同的函数                    
*/

      //  - 面向对象的三大特征分别为：封装，继承和多态
      //  - 1.封装
      //      我们平时所用的方法和类都是一种封装，当我们在项目开发中，
      //      遇到一段功能的代码在好多地方重复使用的时候，我们可以把
      //      他单独封装成一个功能的方法，这样在我们需要使用的地方直接调用就可以了。
      //  - 2.继承
      //      子类继承父类中的方法(目的是让子类的实例调取父类中的属性和方法)
      //  - 3.多态
      //      多态的具体表现为方法重载和方法重写：
      //      方法重载：重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数
      //      方法重写：重写（也叫覆盖）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样
    </script>
    <script>
      // 4_express脚手架.什么是全局作用域?什么是局部作用域?

      /* 
        • 全局作用域

        作用于**所有代码执行的环境**(整个 script 标签内部)或者一个独立的 js 文件。

        • 局部作用域（函数作用域）

        作用于**函数内的代码环境**，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域 
        */

      /*
            （一）全局作用域：
              直接编写在 script 标签之中的JS代码，都是全局作用域；
              或者是一个单独的 JS 文件中的。
              全局作用域在页面打开时创建，页面关闭时销毁；
              在全局作用域中有一个全局对象 window（代表的是一个浏览器的窗口，由浏览器创建），可以直接使用。
            （二）局部作用域（函数作用域）：
              在函数内部就是局部作用域，这个代码的名字只在函数的内部起作用
              调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；
              每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。
        */
    </script>
    <script>
      /*
            5.回调函数、闭包函数、递归函数分别是什么?
                - 回调函数:把一个函数当作参数,传递给另一个函数,另一个函数当中调用传进来的函数
                - 闭包函数:在一个函数当中再声明一个函数,外层函数把内层函数作为返回值
                - 递归函数:自己调用自己,有很多的代码是完全相同的,相同逻辑的代码没有必要反复去书写,从上而下的,然后从下向上回溯
        */
    </script>
    <script>
      /*
            6.原型对象的作用是什么?
                - 原型对象当作仓库,原型对象可以帮 函数对象 存储 方法(方法中代码量远远大于属性)
                - 给函数对象的实例节省内存空间
                - 引用对象再使用方法的时候,优先再当前对象中搜索,如果没有,则去原型对象中查找
                - 牺牲计算时间(微不足道的)
                在js的所有内置对象中都存在prototype原型属性
                在js的内置对象的原型属性中，追加方法，那么该方法会自动追加到内置对象中
                js的原型属性最终的目的是给内置对象追加方法
        */
    </script>
    <script>
      /*
            7.什么是原型链?
            原型链 : 描述的是 函数对象 和 函数对象之间的关系
                   原型链是JS中查找属性或方法的语法
                原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，
                会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，
                即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，
                这样一层一层向上查找就会形成一个链式结构
        */
    </script>
    <script>
      /*
            8.如何实现继承?

            /* 
                1、借用继承
                2、原型继承
                3、原型多继承
                4_express脚手架、实例继承
                5、组合继承
             */
            
        
      // 1.原型链继承
      // 2.借用构造函数继承
      // 3.组合继承（经典继承）
      // 4_express脚手架.原型式继承
      // 方法一：本质上，函数A是对传入的对象执行了一次浅复制。
      // 方法二：Object.create()
      // 5.寄生式继承
      // 6.寄生组合式继承
      // 7.ES6、Class实现继承

      // function person() {
      //     this.name = 'zs';
      //     this.age = 20;
      // }
      // person.prototype.sex = '男'
      // function child() {
      //     person.call(this)//改变指向
      //     this.arr = [1, 2, 3, 4_express脚手架, 5]
      // }
      // console.log(new child()) //child {name: 'zs', age: 20, arr: Array(5)}
    </script>
    <script>
      /*
            9.call方法的作用是什么?
            改变this指向,可以传参
        */
    </script>
    <script>
      /*
            10.this的作用是什么？
             this针对对象而言的
                - 在全局当中代表的是window对象
                - 在函数当中,由于函数不是对象,函数属于window对象,所以输出window对象
            如果this在对象+私有的作用域下,才能表达自己
            如果在函数中使用了this，只有在该函数直接被某对象调用时，该this才指向该对象。
        */
    </script>
  </body>
</html>
